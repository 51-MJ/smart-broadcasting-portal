<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智慧广电 - 广播电视融合传播平台</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <canvas id="canvas-bg"></canvas>

    <div class="container">
        <!-- 顶部导航 -->
        <div class="header">
            <div class="logo">🌐 智慧广电</div>
            <a href="features.html" class="nav-btn">功能介绍</a>
        </div>

        <!-- 中心内容 -->
        <div class="main-content">
            <h1 class="main-title">智慧广电</h1>
            <p class="subtitle">
                连接全球广电内容，实现多渠道融合分发。
                通过人工智能和大数据技术，为用户提供个性化的媒体体验。
            </p>

            <div class="action-buttons">
                <a href="login.html" class="btn-primary">立即登录</a>
                <a href="features.html" class="btn-secondary">了解更多</a>
            </div>
        </div>

        <!-- 底部信息 -->
        <div class="footer">
            <div>© 2026 智慧广电. 保留所有权利。</div>
            <div class="footer-links">
                <a href="#" class="footer-link">隐私政策</a>
                <a href="#" class="footer-link">服务条款</a>
                <a href="#" class="footer-link">联系我们</a>
            </div>
        </div>
    </div>

    <script>
        // ==================== 神经网络背景系统 ====================
        class NeuralNetworkBackground {
            constructor() {
                this.canvas = document.getElementById('canvas-bg');
                this.ctx = this.canvas.getContext('2d');

                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // 神经网络参数 - 降低密度，避免遮挡文字
                this.config = {
                    nodeCount: 60,  // 减少节点数量
                    connectionDistance: 120,  // 缩短连接距离
                    nodeSize: 2.5,
                    animationSpeed: 0.015,
                    pulseSpeed: 0.03,
                    textSafeZone: 200  // 文字安全区域
                };

                this.nodes = [];
                this.connections = [];
                this.pulses = [];
                this.time = 0;

                this.createNetwork();
                this.animate();

                window.addEventListener('resize', () => this.onWindowResize());
            }

            createNetwork() {
                this.nodes = [];
                this.connections = [];

                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const safeZone = this.config.textSafeZone;

                // 创建简洁的圆形分布 - 只在外圈形成环形网络
                const circleRadius = 250;  // 圆形半径
                const nodeCount = 24;  // 总节点数

                // 按照圆形均匀分布节点
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * Math.PI * 2;
                    
                    // 主圆环上的节点
                    let x = centerX + Math.cos(angle) * circleRadius;
                    let y = centerY + Math.sin(angle) * circleRadius;

                    // 添加少量随机偏移（不超过20像素）
                    x += (Math.random() - 0.5) * 20;
                    y += (Math.random() - 0.5) * 20;

                    // 确保在画布范围内
                    x = Math.max(50, Math.min(this.canvas.width - 50, x));
                    y = Math.max(50, Math.min(this.canvas.height - 50, y));

                    // 确定节点类型：顶部为核心，其他为普通节点
                    let type = 'region';
                    let size = this.config.nodeSize;
                    
                    if (Math.abs(angle - Math.PI * 1.5) < Math.PI / 12) {  // 上方的几个节点
                        type = 'core';
                        size = this.config.nodeSize * 1.8;
                    } else if (Math.abs(angle - Math.PI * 0.5) < Math.PI / 6) {  // 下方节点稍小
                        type = 'peripheral';
                        size = this.config.nodeSize * 0.8;
                    }

                    this.nodes.push({
                        x,
                        y,
                        vx: 0,  // 固定节点
                        vy: 0,
                        size: size,
                        activity: Math.random(),
                        phase: Math.random() * Math.PI * 2,
                        type: type
                    });
                }

                // 创建环形连接
                this.createCircleConnections();
            }

            createCircleConnections() {
                // 只连接圆形上相邻的节点 - 形成简洁的环形网络
                const nodeCount = this.nodes.length;

                // 1. 相邻节点连接（环形）
                for (let i = 0; i < nodeCount; i++) {
                    const nextIndex = (i + 1) % nodeCount;

                    this.connections.push({
                        from: i,
                        to: nextIndex,
                        strength: 0.8,
                        distance: Math.sqrt(
                            (this.nodes[nextIndex].x - this.nodes[i].x) ** 2 +
                            (this.nodes[nextIndex].y - this.nodes[i].y) ** 2
                        ),
                        active: true,
                        type: 'highway'
                    });
                }

                // 2. 交叉连接 - 每隔几个节点连接一次（让网络不会太稀疏）
                for (let i = 0; i < nodeCount; i++) {
                    const crossIndex = (i + Math.floor(nodeCount / 4)) % nodeCount;

                    if (crossIndex !== i && crossIndex !== (i + 1) % nodeCount && crossIndex !== (i - 1 + nodeCount) % nodeCount) {
                        this.connections.push({
                            from: i,
                            to: crossIndex,
                            strength: 0.4,
                            distance: Math.sqrt(
                                (this.nodes[crossIndex].x - this.nodes[i].x) ** 2 +
                                (this.nodes[crossIndex].y - this.nodes[i].y) ** 2
                            ),
                            active: Math.random() < 0.6,
                            type: 'secondary'
                        });
                    }
                }
            }

            findNearestNode(point) {
                let nearest = null;
                let minDistance = Infinity;

                this.nodes.forEach(node => {
                    const distance = Math.sqrt((node.x - point.x) ** 2 + (node.y - point.y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = node;
                    }
                });

                return nearest;
            }

            areRegionsAdjacent(region1, region2) {
                if (!region1 || !region2) return false;

                const dx = region1.x - region2.x;
                const dy = region1.y - region2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                return distance < 300;  // 相邻区域距离阈值
            }

            onWindowResize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.createNetwork();
            }

            animate = () => {
                this.time += this.config.animationSpeed;
                this.update();
                this.draw();
                requestAnimationFrame(this.animate);
            }

            update() {
                // 节点固定不动，只更新活跃度和连接状态
                this.nodes.forEach(node => {
                    // 更新节点活跃度 - 让节点有呼吸效果
                    node.activity = 0.5 + 0.3 * Math.sin(this.time * 2 + node.phase);
                });

                // 随机激活连接
                this.connections.forEach(conn => {
                    if (Math.random() < 0.008) {
                        conn.active = !conn.active;
                    }
                });

                // 创建脉冲
                if (Math.random() < 0.015) {
                    const activeConnections = this.connections.filter(c => c.active);
                    if (activeConnections.length > 0) {
                        const randomConn = activeConnections[Math.floor(Math.random() * activeConnections.length)];
                        this.pulses.push({
                            connection: randomConn,
                            progress: 0,
                            speed: this.config.pulseSpeed + Math.random() * 0.01
                        });
                    }
                }

                // 更新脉冲
                this.pulses = this.pulses.filter(pulse => {
                    pulse.progress += pulse.speed;
                    return pulse.progress < 1;
                });
            }

            draw() {
                // 绘制动态背景
                this.drawBackground();

                // 绘制连接线
                this.drawConnections();

                // 绘制脉冲
                this.drawPulses();

                // 绘制节点
                this.drawNodes();
            }

            drawBackground() {
                // 创建深色渐变背景
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 2
                );
                gradient.addColorStop(0, 'rgba(0, 15, 20, 0.1)');
                gradient.addColorStop(0.5, 'rgba(0, 10, 15, 0.08)');
                gradient.addColorStop(1, 'rgba(0, 5, 10, 0.05)');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // 添加一些随机的背景粒子
                for (let i = 0; i < 50; i++) {
                    const x = (i * 37) % this.canvas.width;
                    const y = (i * 23 + this.time * 10) % this.canvas.height;
                    const size = 1 + Math.sin(this.time * 0.5 + i) * 0.5;

                    this.ctx.fillStyle = `rgba(100, 150, 200, ${0.1 + Math.sin(this.time + i) * 0.05})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 添加一些流动的光线效果
                for (let i = 0; i < 8; i++) {
                    const angle = (this.time * 0.2 + i * Math.PI / 4) % (Math.PI * 2);
                    const startX = this.canvas.width / 2 + Math.cos(angle) * 100;
                    const startY = this.canvas.height / 2 + Math.sin(angle) * 100;
                    const endX = this.canvas.width / 2 + Math.cos(angle) * 400;
                    const endY = this.canvas.height / 2 + Math.sin(angle) * 400;

                    const gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
                    gradient.addColorStop(0, 'rgba(100, 150, 220, 0.03)');
                    gradient.addColorStop(0.5, 'rgba(120, 170, 240, 0.02)');
                    gradient.addColorStop(1, 'rgba(100, 150, 220, 0)');

                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                    this.ctx.stroke();
                }
            }

            drawConnections() {
                this.connections.forEach(conn => {
                    const fromNode = this.nodes[conn.from];
                    const toNode = this.nodes[conn.to];

                    if (!fromNode || !toNode) return;

                    // 根据连接类型设置不同的样式
                    let baseColor, alpha, width;
                    if (conn.type === 'highway') {
                        baseColor = '165, 180, 252'; // 蓝色 - 高速连接
                        alpha = conn.active ? 0.7 : 0.4;
                        width = conn.active ? 2.8 : 1.8;
                    } else if (conn.type === 'local') {
                        baseColor = '147, 197, 253'; // 浅蓝色 - 区域内连接
                        alpha = conn.active ? 0.5 : 0.25;
                        width = conn.active ? 2.0 : 1.2;
                    } else if (conn.type === 'secondary') {
                        baseColor = '180, 200, 255'; // 更浅的蓝色 - 次级连接
                        alpha = conn.active ? 0.4 : 0.2;
                        width = conn.active ? 1.6 : 0.9;
                    } else if (conn.type === 'peripheral') {
                        baseColor = '200, 220, 255'; // 最浅的蓝色 - 外围连接
                        alpha = conn.active ? 0.3 : 0.15;
                        width = conn.active ? 1.4 : 0.8;
                    } else {
                        baseColor = '165, 180, 252'; // 默认
                        alpha = conn.active ? 0.4 : 0.2;
                        width = conn.active ? 2 : 1;
                    }

                    // 绘制主连接线
                    this.ctx.strokeStyle = `rgba(${baseColor}, ${alpha})`;
                    this.ctx.lineWidth = width;
                    this.ctx.beginPath();
                    this.ctx.moveTo(fromNode.x, fromNode.y);
                    this.ctx.lineTo(toNode.x, toNode.y);
                    this.ctx.stroke();

                    // 为活跃连接添加流动效果
                    if (conn.active && Math.random() < 0.4) {
                        const flowProgress = (this.time * 0.3 + conn.from * 0.1) % 1;
                        const flowX = fromNode.x + (toNode.x - fromNode.x) * flowProgress;
                        const flowY = fromNode.y + (toNode.y - fromNode.y) * flowProgress;

                        // 流动小点
                        this.ctx.fillStyle = `rgba(${baseColor}, 0.9)`;
                        this.ctx.beginPath();
                        this.ctx.arc(flowX, flowY, 1.8, 0, Math.PI * 2);
                        this.ctx.fill();

                        // 小点光晕
                        const glowGradient = this.ctx.createRadialGradient(flowX, flowY, 0, flowX, flowY, 6);
                        glowGradient.addColorStop(0, `rgba(${baseColor}, 0.5)`);
                        glowGradient.addColorStop(1, `rgba(${baseColor}, 0)`);
                        this.ctx.fillStyle = glowGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(flowX, flowY, 6, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }

            drawPulses() {
                this.pulses.forEach(pulse => {
                    const conn = pulse.connection;
                    const fromNode = this.nodes[conn.from];
                    const toNode = this.nodes[conn.to];

                    if (!fromNode || !toNode) return;

                    const x = fromNode.x + (toNode.x - fromNode.x) * pulse.progress;
                    const y = fromNode.y + (toNode.y - fromNode.y) * pulse.progress;

                    // 脉冲效果 - 更细腻
                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, 8);
                    gradient.addColorStop(0, 'rgba(165, 180, 252, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(165, 180, 252, 0.3)');
                    gradient.addColorStop(1, 'rgba(165, 180, 252, 0)');

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 8, 0, Math.PI * 2);
                    this.ctx.fill();

                    // 脉冲核心
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            drawNodes() {
                this.nodes.forEach(node => {
                    const x = node.x;
                    const y = node.y;
                    const size = node.size * (0.8 + node.activity * 0.3);

                    // 根据节点类型设置不同的光晕
                    if (node.type === 'core') {
                        // 核心节点 - 多层蓝色光晕
                        for (let i = 2; i >= 1; i--) {
                            const glowSize = size + i * 4;
                            const alpha = (3 - i) / 3 * node.activity * 0.4;

                            this.ctx.fillStyle = `rgba(102, 126, 234, ${alpha})`;
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    } else if (node.type === 'region') {
                        // 区域节点 - 紫色光晕
                        const glowSize = size + 6;
                        const alpha = node.activity * 0.3;

                        this.ctx.fillStyle = `rgba(165, 180, 252, ${alpha})`;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        // 外围节点 - 浅色光晕
                        const glowSize = size + 4;
                        const alpha = node.activity * 0.2;

                        this.ctx.fillStyle = `rgba(240, 147, 251, ${alpha})`;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }

                    // 节点主体
                    let color;
                    if (node.type === 'core') {
                        color = `rgba(102, 126, 234, ${0.8 + node.activity * 0.2})`;
                    } else if (node.type === 'region') {
                        color = `rgba(165, 180, 252, ${0.7 + node.activity * 0.3})`;
                    } else {
                        color = `rgba(240, 147, 251, ${0.6 + node.activity * 0.4})`;
                    }

                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();

                    // 节点边框
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${node.activity * 0.4})`;
                    this.ctx.lineWidth = 0.8;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
            }
        }

        // ==================== 页面交互 ====================
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化神经网络背景
            new NeuralNetworkBackground();

            // 按钮点击事件
            document.querySelector('.btn-primary').addEventListener('click', () => {
                window.location.href = 'login.html';
            });

            document.querySelector('.btn-secondary').addEventListener('click', () => {
                window.location.href = 'features.html';
            });
        });
    </script>
</body>
</html>



                <!-- 功能卡片 1 -->
                <article class="feature-card">
                    <div class="card-icon">
                        <i class="fas fa-user-shield"></i>
                    </div>
                    <h3>动态权限管理</h3>
                    <p>基于ABAC（属性基访问控制）算法，实现“用户-区域-数据”三重映射。确保乡镇管理员的操作数据天然隔离，从架构源头杜绝信息跨域泄露。</p>
                    <ul class="feature-tech">
                        <li>Spring Security深度扩展</li>
                        <li>字段级数据隔离</li>
                        <li>权限秒级生效</li>
                    </ul>
                </article>
                <!-- 功能卡片 2 -->
                <article class="feature-card">
                    <div class="card-icon">
                        <i class="fas fa-palette"></i>
                    </div>
                    <h3>多终端自适应</h3>
                    <p>采用Vue3组件化与响应式设计，配合可视化模板引擎。支持管理员零代码拖拽定制门户，并确保在电视大屏与手机端的完美协同显示。</p>
                    <ul class="feature-tech">
                        <li>Vue 3 + Element Plus</li>
                        <li>可视化拖拽编辑</li>
                        <li>多端样式自适配</li>
                    </ul>
                </article>
                <!-- 功能卡片 3 -->
                <article class="feature-card">
                    <div class="card-icon">
                        <i class="fas fa-broadcast-tower"></i>
                    </div>
                    <h3>精准内容推送</h3>
                    <p>构建教育、党建、乡村治理等多场景融合内容服务。基于动态区域标签与智能路由，实现重要通知与服务100%精准触达目标人群。</p>
                    <ul class="feature-tech">
                        <li>场景化内容融合</li>
                        <li>智能区域化标签</li>
                        <li>全链路日志追踪</li>
                    </ul>
                </article>
                <!-- 功能卡片 4 -->
                <article class="feature-card">
                    <div class="card-icon">
                        <i class="fas fa-chart-line"></i>
                    </div>
                    <h3>运营决策支持</h3>
                    <p>集成全链路操作日志追踪与多维度运营数据分析看板。为安全审计与运营决策提供直观的数据支撑，助力基层数字化治理。</p>
                    <ul class="feature-tech">
                        <li>ELK日志分析栈</li>
                        <li>ECharts可视化</li>
                        <li>实时异常告警</li>
                    </ul>
                </article>
            </div>
        </section>

        <!-- 平台简介 -->
        <section id="about" class="about-section">
            <h2><i class="fas fa-info-circle"></i> 平台简介</h2>
            <div class="about-content">
                <div class="about-text">
                    <p>智慧广电门户系统平台是一个利用现代信息技术，旨在提升基层治理效率的<strong>综合性数字服务平台</strong>。</p>
                    <p>针对传统系统存在的<em>权限管理粗放、定制成本高昂、信息协同困难</em>等核心问题，本平台通过创新的动态权限算法与多终端自适应技术，实现了：</p>
                    <dl class="about-list">
                        <dt><i class="fas fa-check-circle"></i> 数据安全精准管控</dt>
                        <dd>权限与行政层级智能匹配，确保数据在乡镇、村社间严格隔离。</dd>
                        
                        <dt><i class="fas fa-check-circle"></i> 门户灵活零代码定制</dt>
                        <dd>基层管理员可通过拖拽方式，快速构建符合本地特色的宣传与服务门户。</dd>
                        
                        <dt><i class="fas fa-check-circle"></i> 多业务场景深度融合</dt>
                        <dd>打通政务、教育、党建、民生等业务，为群众提供一站式服务入口。</dd>
                    </dl>
                </div>
                <div class="about-image">
                    <!-- 占位，未来可替换为平台架构图 -->
                    <div class="arch-placeholder">
                        <div class="arch-node">用户层</div>
                        <div class="arch-node">业务层</div>
                        <div class="arch-node">数据层</div>
                        <div class="arch-line"></div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="main-footer">
        <div class="container footer-container">
            <div class="footer-info">
                <p><strong>智慧广电门户系统</strong> — 西南民族大学大学生创新创业训练计划项目</p>
                <p class="footer-note">© 2025 基于动态权限算法的智慧广电门户系统研发团队。本页面为项目原型展示。</p>
            </div>
            <div class="footer-links">
                <a href="#"><i class="fab fa-github"></i> 项目仓库</a>
                <a href="#"><i class="fas fa-file-contract"></i> 项目文档</a>
            </div>
        </div>
    </footer> 

    <!-- 可选的返回顶部按钮 -->
    <a href="#" class="back-to-top" aria-label="返回顶部"><i class="fas fa-chevron-up"></i></a>
<!-- 引入JavaScript文件 -->
<script type="module" src="js/main.js"></script>

<!-- 添加用户信息和时间显示区域 -->
<div id="user-info" class="user-info"></div>
<div id="current-datetime" class="datetime-display"></div>
</body>

</html>